1d0
< from code import interact
3d1
< from site import USER_SITE
6d3
< from sqlalchemy import true
18,19d14
< # HEIGHT, WIDTH = 8 , 8
< # HEIGHT_ALL, WIDTH_ALL = 10.0, 10.0
22,23d16
< # HEIGHT, WIDTH = 12, 12
< # HEIGHT_ALL, WIDTH_ALL = 12, 17
64d56
<         # self.v_list = [obj(1.0, 1.0, 0.5)]
68c60
<         # self.v_list = [obj(3.0, 2.0, 0.5), obj(3.0, 10.0, 0.5), obj(14.0, 2.0, 0.5)]
---
>     
71,73d62
<         # self.p_list = [obj(6.0, 2.0, 0.5), obj(2.0, 10.0, 0.5), obj(10.0, 10.0, 0.5)]
<         # self.p_list = [obj(1.5, 4.0, 0.5), obj(6.5, 6.0, 0.5), obj(4, 1.5, 0.5)]
<         # self.p_list = [obj(7.0, 1.0, 0.5), obj(1.0, 7.0, 0.5)]
75,76c64,65
<         # self.obstacle_list = [obstacle("square", 8.0, 3.0, 2.0)]
<         self.obstacle_list = []
---
>         # self.p_list = [obj(1.5, 4.0, 0.5), obj(6.5, 6.0, 0.5), obj(4, 1.5, 0.5)]
>         # self.p_list = [obj(10.0, 10.0, 0.5)]
123,124d111
<             if self.v_step_pointer == len(self.v_path): # Ends the v_path
<                 break
131c118,123
<                 break                           
---
>                 break
>             
>             if self.v_step_pointer >= len(self.v_path) - 1: # Ends the v_path
>                 break
>             if self.touch != -1:
>                 reward, _ = self.final_reward()                            
135c127
<         obs = self.obs[-OBSERVATION_SPACE * (self.num_frame_stack - 1):]
---
>         obs = self.obs[OBSERVATION_SPACE:]                  # update the observation after k steps 
137d128
< 
148d138
< 
166c156
<         if outbound(self.x_p, self.y_p) or self.insideObstacle(self.x_p, self.y_p):
---
>         if outbound(self.x_p, self.y_p):
171,177d160
<     def insideObstacle(self, tmp_x, tmp_y):
<         for obstacle in self.obstacle_list:
<             if tmp_x >= obstacle.x - obstacle.r and tmp_x <= obstacle.x + obstacle.r and tmp_y >= obstacle.y - obstacle.r and tmp_y <= obstacle.y + obstacle.r:
<                 return True
<         return False
<             
< 
183a167
> 
189c173
<         if outbound(tmp_x, tmp_y) or self.insideObstacle(tmp_x, tmp_y):
---
>         if outbound(tmp_x, tmp_y):
239d222
<         dis = 0.0
273a257,260
>                         # self.reward += self.final_reward()
>                         break
>                     # signal = self.physical_step(gt, gr, gc)
>                     if not signal:
276d262
<                     dis += VELOCITY
304c290
<         return self.reward, ave_gap_dis, pde_list, 1, touch_cnt, gt_l, gr_l, gc_l, x_l, y_l, vx_l, vy_l, std1, std2, std3, collide, dis
---
>         return self.reward, ave_gap_dis, pde_list, 1, touch_cnt, gt_l, gr_l, gc_l, x_l, y_l, vx_l, vy_l, std1, std2, std3, collide
312,313c298,299
<         #p_target = self.p_prop_list[int(self.touch)]
<         #x_t, y_t  = self.p_list[p_target].x, self.p_list[p_target].y
---
>         p_target = self.p_prop_list[int(self.touch)]
>         x_t, y_t  = self.p_list[p_target].x, self.p_list[p_target].y
315c301
<         #gap_dis = distance(self.x_p/WIDTH, self.y_p/HEIGHT, x_t/WIDTH, y_t/HEIGHT)
---
>         gap_dis = distance(self.x_p/WIDTH, self.y_p/HEIGHT, x_t/WIDTH, y_t/HEIGHT)
378,379d363
<                 intersect = 0
<                 # intersect = self.get_reward_intersect(j)
381,382c365,366
<                 if (o + 3 *d + intersect) < unalign_min:
<                     unalign_min = o + 3 * d + intersect
---
>                 if (o + 3 * d) < unalign_min:
>                     unalign_min = o + 3 * d
394,398d377
<         # d1 = distance(self.x_p/WIDTH,     self.y_p/HEIGHT,     self.p_list[p].x/WIDTH,     self.p_list[p].y/  HEIGHT)
<         # d2 = distance(self.x_v/WIDTH_ALL, self.y_v/HEIGHT_ALL, self.v_list[v].x/WIDTH_ALL, self.v_list[v].y/  WIDTH_ALL)
<         # d1 = distance(self.x_p, self.y_p, self.p_list[p].x, self.p_list[p].y)
<         # d2 = distance(self.x_v, self.y_v, self.v_list[v].x, self.v_list[v].y)
<         # return toTensor(abs(d1 - d2) / (WIDTH_ALL * 1.41))
440,447d418
<     
<     
<     def get_reward_intersect(self, j):
<         prop = self.p_list[j]
<         if self.isIntersectProp(prop):
<             return 1.0
<         else:
<             return 0.0
450,471d420
<     def isIntersectProp(self, prop):
<         for obstacle in self.obstacle_list:
<             if self.isIntersectObstacle(prop, obstacle):
<                 return True
<         return False
<             
<     def isIntersectObstacle(self, prop, obstacle):
<         # whether two linesegment intersect
<         if obstacle.name == "square": # test each edge
<             heading_seg = Segment(Point(self.x_p, self.y_p), Point(prop.x, prop.y))
<             left_b  = Point(obstacle.x - obstacle.r, obstacle.y - obstacle.r)
<             left_u  = Point(obstacle.x - obstacle.r, obstacle.y + obstacle.r)
<             right_u = Point(obstacle.x + obstacle.r, obstacle.y + obstacle.r)
<             right_b = Point(obstacle.x + obstacle.r, obstacle.y - obstacle.r)
<             # Four segment
<             l_seg = Segment(left_u, left_b)
<             r_seg = Segment(right_u, right_b)
<             u_seg = Segment(left_u, right_u)
<             b_seg = Segment(left_b, right_b)
<             return heading_seg.is_cross(l_seg) or heading_seg.is_cross(r_seg) or heading_seg.is_cross(u_seg) or heading_seg.is_cross(b_seg)
<         
<     
504,505c453,454
<     # a = 2.2 + 2 * a
<     # b = 2.2 + 2 * b
---
>     # a = 1 + 0.5 * a
>     # b = 1 + 0.5 * b
518,519d466
<     # if x <= 0 or x >= WIDTH or y <= 0 or y >= HEIGHT or (x >= 6  and x <= 10 and y >= 0 and y <= 4):
<     #     return True
524d470
<     
575,644d520
<         
< 
< # Obstacle in environment, have shape of rectangle and circle
< class obstacle:
<     def __init__(self, m_type, m_x, m_y, m_r):
<         self.name = m_type
<         self.x = m_x
<         self.y = m_y
<         self.r = m_r
< 
< 
< def multiply(v1, v2):  
<     """ 
<     计算两个向量的叉积 
<     """  
<     return v1.x*v2.y - v2.x*v1.y  
<   
<   
< class Point:  
<     def __init__(self, x, y):  
<         self.x = x  
<         self.y = y  
<   
<     def __sub__(self, other):  
<         """ 
<         重载减法运算，计算两点之差，实际上返回的表示该点到另一点的向量 
<         :param other: 另一个点 
<         :return: 该点到另一点的向量 
<         """  
<         return Point(self.x-other.x, self.y-other.y)  
<   
<   
< class Segment:  
<     def __init__(self, point1, point2):  
<         self.point1 = point1  
<         self.point2 = point2  
<   
<     def straddle(self, another_segment):  
<         """ 
<         :param another_segment: 另一条线段 
<         :return: 如果另一条线段跨立该线段，返回True；否则返回False 
<         """  
<         v1 = another_segment.point1 - self.point1  
<         v2 = another_segment.point2 - self.point1  
<         vm = self.point2 - self.point1  
<         if multiply(v1, vm) * multiply(v2, vm) <= 0:  
<             return True  
<         else:  
<             return False  
<   
<     def is_cross(self, another_segment):  
<         """ 
<         :param another_segment: 另一条线段 
<         :return: 如果两条线段相互跨立，则相交；否则不相交 
<         """  
<         if self.straddle(another_segment) and another_segment.straddle(self):  
<             return True  
<         else:  
<             return False  
<   
<     def cross(self, another_segment):  
<         if self.is_cross(another_segment):  
<             print('两线段相交.')  
<         else:  
<             print('两线段不相交.')  
<         plt.plot([self.point1.x, self.point2.x], [self.point1.y, self.point2.y])  
<         plt.plot([another_segment.point1.x, another_segment.point2.x],  
<                  [another_segment.point1.y, another_segment.point2.y])  
<         plt.show()  
< 
